/**
 * GitHub Integration
 * 
 * Provides integration with GitHub APIs for deploying agents,
 * creating PRs, managing secrets, and GitHub Actions workflows.
 */

import { GeneratedAgent, AgentSpec } from './agentGenerator';
import { logger } from './logger';

export interface GitHubConfig {
    token: string;
    owner: string;
    repo: string;
}

export interface DeploymentConfig {
    environment: 'development' | 'staging' | 'production';
    branch?: string;
    schedule?: string;
    secrets: string[];
    variables?: Record<string, string>;
}

export interface PRCreateResult {
    success: boolean;
    prNumber?: number;
    prUrl?: string;
    error?: string;
    files: string[];
}

export interface WorkflowConfig {
    name: string;
    trigger: WorkflowTrigger;
    environment?: string;
    secrets: string[];
    steps: WorkflowStep[];
}

export interface WorkflowTrigger {
    type: 'schedule' | 'push' | 'pull_request' | 'workflow_dispatch' | 'webhook';
    schedule?: string;  // cron expression
    branches?: string[];
    paths?: string[];
}

export interface WorkflowStep {
    name: string;
    uses?: string;  // Action to use
    run?: string;   // Command to run
    with?: Record<string, string>;
    env?: Record<string, string>;
}

export interface SecretValidation {
    name: string;
    exists: boolean;
    required: boolean;
}

export class GitHubIntegration {
    private config?: GitHubConfig;

    constructor(config?: GitHubConfig) {
        this.config = config;
    }

    /**
     * Generate files for PR creation
     */
    generatePRFiles(agent: GeneratedAgent, config: DeploymentConfig): PRFiles {
        const files: PRFiles = {
            agentCode: [],
            workflow: null,
            policy: null,
            tests: null,
            readme: null
        };

        // Agent code file
        if (agent.code.python) {
            files.agentCode.push({
                path: `agents/${this.toSnakeCase(agent.spec.name)}.py`,
                content: agent.code.python
            });
        }
        if (agent.code.typescript) {
            files.agentCode.push({
                path: `agents/${this.toKebabCase(agent.spec.name)}.ts`,
                content: agent.code.typescript
            });
        }

        // GitHub Actions workflow
        if (agent.workflowYaml || agent.spec.schedule) {
            files.workflow = {
                path: `.github/workflows/${this.toKebabCase(agent.spec.name)}.yml`,
                content: agent.workflowYaml || this.generateWorkflowYaml(agent.spec, config)
            };
        }

        // Policy file
        files.policy = {
            path: `policies/${this.toKebabCase(agent.spec.name)}.yaml`,
            content: agent.policies
        };

        // Tests
        if (agent.tests) {
            files.tests = {
                path: `tests/test_${this.toSnakeCase(agent.spec.name)}.py`,
                content: agent.tests
            };
        }

        // README
        files.readme = {
            path: `agents/${this.toKebabCase(agent.spec.name)}/README.md`,
            content: this.generateAgentReadme(agent.spec)
        };

        return files;
    }

    /**
     * Generate GitHub Actions workflow YAML
     */
    generateWorkflowYaml(spec: AgentSpec, config: DeploymentConfig): string {
        const workflowName = spec.name.replace(/([A-Z])/g, ' $1').trim();
        const envVars = this.getRequiredSecrets(spec);
        
        let yaml = `# ${workflowName}
# Generated by AgentOS for GitHub Copilot
# ${spec.description}

name: ${workflowName}

on:
`;

        // Schedule trigger
        if (spec.schedule) {
            yaml += `  schedule:
    - cron: '${spec.schedule}'
`;
        }

        // Manual trigger
        yaml += `  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: '${config.environment}'
        type: choice
        options:
          - development
          - staging
          - production
`;

        // Push trigger for non-production
        if (config.environment !== 'production') {
            yaml += `  push:
    branches:
      - ${config.branch || 'main'}
    paths:
      - 'agents/${this.toKebabCase(spec.name)}/**'
      - '.github/workflows/${this.toKebabCase(spec.name)}.yml'
`;
        }

        yaml += `
env:
  AGENT_NAME: ${this.toSnakeCase(spec.name)}
  ENVIRONMENT: \${{ inputs.environment || '${config.environment}' }}

jobs:
  run-agent:
    runs-on: ubuntu-latest
    environment: \${{ env.ENVIRONMENT }}
    
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install Agent OS
        run: |
          pip install agent-os
          pip install -r requirements.txt || true
      
      - name: Validate policies
        run: |
          agentos check policies/${this.toKebabCase(spec.name)}.yaml
      
      - name: Run Agent
        id: run-agent
        uses: agentos/run-agent@v1
        with:
          agent: agents/${this.toSnakeCase(spec.name)}.py
          policy: policies/${this.toKebabCase(spec.name)}.yaml
          environment: \${{ env.ENVIRONMENT }}
        env:
${envVars.map(v => `          ${v}: \${{ secrets.${v} }}`).join('\n')}
      
      - name: Upload execution logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: agent-logs-\${{ github.run_id }}
          path: |
            logs/
            .agentos/audit.log
          retention-days: 30
      
      - name: Report status
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'ðŸš¨ Agent ${spec.name} failed',
              body: 'Agent execution failed. Check the [workflow run](\${{ github.server_url }}/\${{ github.repository }}/actions/runs/\${{ github.run_id }}) for details.',
              labels: ['agent-failure', 'automated']
            })
`;

        return yaml;
    }

    /**
     * Generate GitHub Actions workflow for deployment with approval
     */
    generateDeploymentWorkflow(spec: AgentSpec, config: DeploymentConfig): string {
        let yaml = `# ${spec.name} Deployment Pipeline
# Generated by AgentOS for GitHub Copilot

name: Deploy ${spec.name}

on:
  push:
    branches:
      - main
    paths:
      - 'agents/${this.toKebabCase(spec.name)}/**'
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Run tests
        run: |
          pip install agent-os pytest
          pytest tests/test_${this.toSnakeCase(spec.name)}.py -v

  security-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Security scan
        run: |
          pip install agent-os
          agentos check agents/${this.toSnakeCase(spec.name)}.py --security

  deploy-staging:
    needs: [test, security-scan]
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - uses: actions/checkout@v4
      - name: Deploy to staging
        run: |
          echo "Deploying to staging..."
          # Add staging deployment steps

  deploy-production:
    needs: deploy-staging
    runs-on: ubuntu-latest
    environment: 
      name: production
      url: https://agents.example.com/${this.toKebabCase(spec.name)}
    steps:
      - uses: actions/checkout@v4
      - name: Deploy to production
        run: |
          echo "Deploying to production..."
          # Add production deployment steps
`;

        return yaml;
    }

    /**
     * Validate that required secrets exist
     */
    validateSecrets(spec: AgentSpec): SecretValidation[] {
        const requiredSecrets = this.getRequiredSecrets(spec);
        
        return requiredSecrets.map(name => ({
            name,
            exists: false,  // Would need API call to verify
            required: true
        }));
    }

    /**
     * Generate PR description
     */
    generatePRDescription(spec: AgentSpec): string {
        return `## ðŸ¤– New Agent: ${spec.name}

### Description
${spec.description}

### Tasks
${spec.tasks.map(t => `- ${t}`).join('\n')}

### Data Sources
${spec.dataSources.map(s => `- ${s}`).join('\n')}

### Outputs
${spec.outputs.map(o => `- ${o}`).join('\n')}

### Policies Applied
${spec.policies.map(p => `- **${p.name}** (${p.type}): ${p.description}`).join('\n')}

### Required Secrets
${this.getRequiredSecrets(spec).map(s => `- \`${s}\``).join('\n')}

### Schedule
${spec.schedule ? `Runs on cron: \`${spec.schedule}\`` : 'On-demand (manual trigger)'}

---

### Checklist
- [ ] Agent code reviewed
- [ ] Policies verified
- [ ] Required secrets configured
- [ ] Tests passing
- [ ] Security scan passed

---
*Generated by AgentOS for GitHub Copilot*
`;
    }

    /**
     * Format deployment info for chat
     */
    formatDeploymentInfo(prResult: PRCreateResult, config: DeploymentConfig): string {
        if (!prResult.success) {
            return `## âŒ Deployment Failed

**Error:** ${prResult.error}

Please check your GitHub token and repository permissions.
`;
        }

        return `## ðŸš€ Agent Deployment Initiated

### Pull Request Created
- **PR:** #${prResult.prNumber}
- **URL:** ${prResult.prUrl}
- **Environment:** ${config.environment}

### Files Created
${prResult.files.map(f => `- \`${f}\``).join('\n')}

### Next Steps
1. Review the PR
2. Ensure required secrets are configured
3. Merge to trigger deployment

### Required Secrets
${config.secrets.map(s => `- \`${s}\``).join('\n')}

---
*Use \`@agentos deploy status\` to check deployment progress*
`;
    }

    /**
     * Generate secrets setup instructions
     */
    generateSecretsInstructions(secrets: string[]): string {
        if (secrets.length === 0) {
            return 'No secrets required for this agent.';
        }

        return `## ðŸ” Required Secrets Setup

The following secrets need to be configured in your repository:

${secrets.map(secret => {
    const instructions = this.getSecretInstructions(secret);
    return `### ${secret}
${instructions}
`;
}).join('\n')}

### How to Add Secrets

1. Go to your repository on GitHub
2. Click **Settings** â†’ **Secrets and variables** â†’ **Actions**
3. Click **New repository secret**
4. Add each secret listed above

Or use the GitHub CLI:
\`\`\`bash
${secrets.map(s => `gh secret set ${s}`).join('\n')}
\`\`\`
`;
    }

    // Private helper methods

    private generateAgentReadme(spec: AgentSpec): string {
        return `# ${spec.name}

${spec.description}

## Tasks
${spec.tasks.map(t => `- ${t}`).join('\n')}

## Data Sources
${spec.dataSources.map(s => `- ${s}`).join('\n')}

## Outputs
${spec.outputs.map(o => `- ${o}`).join('\n')}

## Policies
${spec.policies.map(p => `- **${p.name}**: ${p.description}`).join('\n')}

## Schedule
${spec.schedule ? `Runs on cron: \`${spec.schedule}\`` : 'On-demand'}

## Usage

### Manual Run
\`\`\`bash
gh workflow run ${this.toKebabCase(spec.name)}.yml
\`\`\`

### Local Development
\`\`\`bash
# Install dependencies
pip install agent-os

# Run locally
python agents/${this.toSnakeCase(spec.name)}.py
\`\`\`

## Required Secrets
${this.getRequiredSecrets(spec).map(s => `- \`${s}\``).join('\n')}

---
*Generated by AgentOS for GitHub Copilot*
`;
    }

    private getRequiredSecrets(spec: AgentSpec): string[] {
        const secrets: string[] = [];
        
        for (const source of spec.dataSources) {
            if (source.includes('Slack')) secrets.push('SLACK_TOKEN');
            if (source.includes('GitHub')) secrets.push('GITHUB_TOKEN');
            if (source.includes('Jira')) secrets.push('JIRA_TOKEN', 'JIRA_URL');
            if (source.includes('Database') || source.includes('SQL')) secrets.push('DATABASE_URL');
            if (source.includes('REST API')) secrets.push('API_KEY');
        }
        
        for (const output of spec.outputs) {
            if (output === 'Slack') secrets.push('SLACK_WEBHOOK_URL');
            if (output === 'Email') secrets.push('SMTP_HOST', 'SMTP_USER', 'SMTP_PASSWORD');
            if (output === 'PagerDuty') secrets.push('PAGERDUTY_KEY');
        }
        
        return [...new Set(secrets)];
    }

    private getSecretInstructions(secret: string): string {
        const instructions: Record<string, string> = {
            'SLACK_TOKEN': 'Bot token from your Slack app. Get it from: https://api.slack.com/apps â†’ Your App â†’ OAuth & Permissions',
            'SLACK_WEBHOOK_URL': 'Incoming webhook URL. Create one at: https://api.slack.com/apps â†’ Incoming Webhooks',
            'GITHUB_TOKEN': 'Personal access token or fine-grained token. Create at: https://github.com/settings/tokens',
            'JIRA_TOKEN': 'API token from Atlassian. Create at: https://id.atlassian.com/manage-profile/security/api-tokens',
            'JIRA_URL': 'Your Jira instance URL (e.g., https://yourcompany.atlassian.net)',
            'DATABASE_URL': 'Database connection string (e.g., postgresql://user:pass@host:5432/db)',
            'API_KEY': 'API key for the external service',
            'SMTP_HOST': 'SMTP server hostname (e.g., smtp.gmail.com)',
            'SMTP_USER': 'SMTP username/email',
            'SMTP_PASSWORD': 'SMTP password or app-specific password',
            'PAGERDUTY_KEY': 'PagerDuty API key or integration key'
        };
        
        return instructions[secret] || 'Configure the appropriate value for this secret';
    }

    private toSnakeCase(str: string): string {
        return str
            .replace(/([A-Z])/g, '_$1')
            .toLowerCase()
            .replace(/^_/, '')
            .replace(/[^a-z0-9_]/g, '_')
            .replace(/_+/g, '_');
    }

    private toKebabCase(str: string): string {
        return str
            .replace(/([A-Z])/g, '-$1')
            .toLowerCase()
            .replace(/^-/, '')
            .replace(/[^a-z0-9-]/g, '-')
            .replace(/-+/g, '-');
    }
}

interface PRFiles {
    agentCode: { path: string; content: string }[];
    workflow: { path: string; content: string } | null;
    policy: { path: string; content: string } | null;
    tests: { path: string; content: string } | null;
    readme: { path: string; content: string } | null;
}
